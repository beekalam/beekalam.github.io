<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2017-01-18 Wed 18:17 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title></title>
<meta name="generator" content="Org mode" />
<meta name="author" content="moh" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgc76213f">1. character strings</a>
<ul>
<li><a href="#orgaafbaec">1.1. Character String Literals (String Constants)</a></li>
<li><a href="#org13cc1a2">1.2. Character String Arrays and Initialization</a></li>
<li><a href="#orgd3426ae">1.3. Array Versus Pointer</a></li>
<li><a href="#orgc4c1487">1.4. Array and pointer differences</a></li>
<li><a href="#org1d5cf6a">1.5. Arrays of character Strings</a></li>
<li><a href="#org1aa4b69">1.6. Pointers and Strings</a></li>
<li><a href="#org0e07ab0">1.7. string input</a>
<ul>
<li><a href="#orgd58de90">1.7.1. alternatives to gets</a></li>
<li><a href="#orgdfb44c9">1.7.2. scanf() function</a></li>
</ul>
</li>
<li><a href="#org0dbef1a">1.8. string output</a></li>
<li><a href="#orgec1c9ec">1.9. Null character and Null pointer</a></li>
<li><a href="#org15afa4f">1.10. string length example</a></li>
<li><a href="#org8c095ff">1.11. concatenation of strings example</a></li>
<li><a href="#orgc6af7a1">1.12. startsWith</a></li>
<li><a href="#org3eecf7d">1.13. equalStrings example</a></li>
<li><a href="#org5b383f3">1.14. read string with scanf</a></li>
<li><a href="#org2824c3f">1.15. reading lines of code</a></li>
<li><a href="#orgaefb6f2">1.16. Initializing and Displaying Character Strings</a></li>
<li><a href="#org99cceb4">1.17. Counting words</a></li>
<li><a href="#orgeaca293">1.18. Converting a String to its Integer Equivalent</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgc76213f" class="outline-2">
<h2 id="orgc76213f"><span class="section-number-2">1</span> character strings</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-orgaafbaec" class="outline-3">
<h3 id="orgaafbaec"><span class="section-number-3">1.1</span> Character String Literals (String Constants)</h3>
<div class="outline-text-3" id="text-1-1">
<p>
A string literal, also termed a string constant, is anything enclosed in double quotation
marks.
Character string constants are placed in the static storage class, which means that if you use
a string constant in a function, the string is stored just once and lasts for the duration of the
program, even if the function is called several times. 
</p>
</div>
</div>
<div id="outline-container-org13cc1a2" class="outline-3">
<h3 id="org13cc1a2"><span class="section-number-3">1.2</span> Character String Arrays and Initialization</h3>
<div class="outline-text-3" id="text-1-2">
<p>
When you define a character string array, you must let the compiler know how much space
is needed. One way is to specify an array size large enough to hold the string. The following
declaration initializes the array m1 to the characters of the indicated string:
</p>

<div class="org-src-container">
<pre class="src src-c">const char m1[40] = "Limit yourself to one line's worth.";
</pre>
</div>

<p>
The const indicates the intent to not alter this string.
This form of initialization is short for the standard array initialization form:
</p>
<div class="org-src-container">
<pre class="src src-c">const char m1[40] = { 'L',
'i', 'm', 'i', 't', ' ', 'y', 'o', 'u', 'r', 's', 'e', 'l',
'f', ' ', 't', 'o', ' ', 'o', 'n', 'e', ' ',
'l', 'i', 'n', 'e', '\", 's', ' ', 'w', 'o', 'r',
't', 'h', '.', '\0'
};
</pre>
</div>

<p>
Letting the compiler compute the size of the array works only if you initialize the array. If you
create an array you intend to fill later, you need to specify the size when you declare it. When
you do declare an array size, the array size must evaluate to an integer. Prior to the advent of
variable length arrays (VLAs) with C99, the size had to be an integer constant, which includes
the possibility of an expression formed from constant integer values. 
</p>
<div class="org-src-container">
<pre class="src src-c">int n = 8;
 char cookies[1]; // valid
 char cakes[2 + 5]; // valid, size is a constant expression
 char pies[2*sizeof(long double) + 1]; // valid
 char crumbs[n]; // invalid prior to C99, a VLA after C99
</pre>
</div>

<p>
The name of a character array, like any array name, yields the address of the first element of
the array. Therefore, the following holds:
</p>

<div class="org-src-container">
<pre class="src src-c">char car[10] = "Tata";
car == &amp;car[0] , *car == 'T', and *(car+1) == car[1] == 'a'
</pre>
</div>

<p>
Indeed, you can use pointer notation to set up a string. For example, Listing 11.1uses the
following declaration:
</p>

<div class="org-src-container">
<pre class="src src-c">const char * pt1 = "Something is pointing at me.";
</pre>
</div>

<p>
This declaration is very nearly the same as this one:
</p>

<div class="org-src-container">
<pre class="src src-c">const char ar1[] = "Something is pointing at me.";
</pre>
</div>

<p>
The declarations amount to saying that both pt1 and ar1 are addresses of strings. In both
cases, the quoted string itself determines the amount of storage set aside for the string.
Nonetheless, the forms are not identical. 
</p>

<p>
Note the closing null character. Without it, you have a character array, but not a string. 
</p>
</div>
</div>

<div id="outline-container-orgd3426ae" class="outline-3">
<h3 id="orgd3426ae"><span class="section-number-3">1.3</span> Array Versus Pointer</h3>
<div class="outline-text-3" id="text-1-3">
<p>
What is the difference, then, between an array and a pointer form? The array form ( ar1[] )
causes an array of 29 elements (one for each character plus one for the terminating '\0') to
be allocated in the computer memory. Each element is initialized to the corresponding character
of the string literal. Typically, what happens is that the quoted string is stored in a data
segment that is part of the executable file; when the program is loaded into memory, so is that
string. The quoted string is said to be in static memory. <b>But the memory for the array is allocated
only after the program begins running.</b> At that time, the quoted string is copied into the
array. Note that, at this time, there are two copies of the string. One is the
string literal in static memory, and one is the string stored in the ar1 array.
</p>

<p>
Hereafter, the compiler will recognize the name ar1 as a synonym for the address of the first
array element, &amp;ar1[0]. One important point here is that in the array form, ar1 is an address
constant. You can’t change ar1, because that would mean changing the location (address)
where the array is stored. You can use operations such as ar1+1 to identify the next element in
an array, but ++ar1 is not allowed. The increment operator can be used only with the names of
variables (or, more generally, modifiable lvalues), not with constants.
</p>

<p>
The pointer form ( *pt1) also causes 29 elements in static storage to be set aside for the string.
In addition, once the program begins execution, it sets aside one more storage location for the
pointer variable pt1 and stores the address of the string in the pointer variable. This variable
initially points to the first character of the string, but the value can be changed. Therefore, you
can use the increment operator. For instance, ++pt1 would point to the second character ( o ).
A string literal is considered to be const data. Because pt1 points to that data, it should be
declared as pointing to const data. This doesn’t mean you can’t change the value of pt1 (i.e.,
where it points), but it does mean you can’t use pt1 to change the data itself. If you copy a
string literal to an array, on the other hand, you are free to change the data unless you choose
to declare the array as const . 
In short, initializing the array copies a string from static storage to the array, whereas initializing
the pointer merely copies the address of the string. Listing 11.3illustrates these points. 
</p>
<div class="org-src-container">
<pre class="src src-c">// addresses.c -- addresses of strings
#define MSG "I'm special."
#include &lt;stdio.h&gt;
int main()
{
char ar[] = MSG;
const char *pt = MSG;
printf("address of \"I'm special\": %p \n", "I'm special");
printf(" address ar: %p\n", ar);
printf(" address pt: %p\n", pt);
printf(" address of MSG: %p\n", MSG);
printf("address of \"I'm special\": %p \n", "I'm special");
return 0;
}
</pre>
</div>

<p>
Here’s the output from one system:
 address of "I'm special": 0x100000f0c
 address ar: 0x7fff5fbff8c7
 address pt: 0x100000ee0
 address of MSG: 0x100000ee0
 address of "I'm special": 0x100000f0c 
</p>

<p>
What does this show? First, pt and MSG are the same address, while ar is a different address,
just as promised. Second, although the string literal "I'm special." occurs twice in the
printf() statements, the compiler chose to use one storage location, but not the same address
as MSG. The compiler has the freedom to store a literal that’s used more than once in one or
more locations. Another compiler might choose to represent all three occurrences of "I'm
special." with a single storage location. Third, the part of memory used for static data is
different from that used for dynamic memory, the memory used for ar. Not only are the values 
different, but this particular compiler even uses a different number of bits to represent the two
kinds of memory.
Are the differences between array and pointer representations of strings important? Often they
are not, but it depends on what you try to do. Let’s look further into the matter. 
</p>
</div>
</div>

<div id="outline-container-orgc4c1487" class="outline-3">
<h3 id="orgc4c1487"><span class="section-number-3">1.4</span> Array and pointer differences</h3>
<div class="outline-text-3" id="text-1-4">
<p>
Let’s examine the differences between initializing a character array to hold a string and initializing
a pointer to point to a string. (By “pointing to a string,” we really mean pointing to the
first character of a string.) For example, consider these two declarations:
</p>
<div class="org-src-container">
<pre class="src src-c">char heart[] = "I love Tillie!";
const char *head = "I love Millie!";
</pre>
</div>

<p>
The chief difference is that the array name heart is a constant, but the pointer head is a variable.
What practical difference does this make?
First, both can use array notation:
</p>
<div class="org-src-container">
<pre class="src src-c">for (i = 0; i &lt; 6; i++)
putchar(heart[i]);
putchar('\n');
for (i = 0; i &lt; 6; i++)
putchar(head[i]));
putchar('\n');
</pre>
</div>

<p>
This is the output:
 I love
 I love
</p>

<p>
Next, both can use pointer addition:
</p>
<div class="org-src-container">
<pre class="src src-c">for (i = 0; i &lt; 6; i++)
putchar(*(heart + i));
putchar('\n');
for (i = 0; i &lt; 6; i++)
putchar(*(head + i));
putchar('\n');
</pre>
</div>

<p>
Again, the output is as follows:
 I love
 I love
</p>

<p>
Only the pointer version, however, can use the increment operator:
</p>
<div class="org-src-container">
<pre class="src src-c">while (*(head) != '\0') /* stop at end of string */
putchar(*(head++)); /* print character, advance pointer */
</pre>
</div>

<p>
This produces the following output:
 I love Millie!
</p>

<p>
Suppose you want head to agree with heart. You can say
</p>

<p>
head = heart; <i>* head now points to the array heart *</i>
</p>

<p>
This makes the head pointer point to the first element of the heart array.
However, you cannot say
</p>

<p>
heart = head; <i>* illegal construction *</i>
</p>

<p>
The situation is analogous to x = 3; versus 3 = x;. The left side of the assignment statement
must be a variable or, more generally, a modifiable lvalue, such as *p<sub>int</sub>. Incidentally, head
= heart; does not make the Millie string vanish; it just changes the address stored in head .
Unless you’ve saved the address of "I love Millie!" elsewhere, however, you won’t be able
to access that string when head points to another location.
</p>

<p>
There is a way to alter the heart message—go to the individual array elements:
</p>

<p>
heart[7]= 'M';
or
*(heart + 7) = 'M';
</p>

<p>
The elements of an array are variables (unless the array was declared as const), but the name is
not a variable.
</p>

<p>
Let’s go back to a pointer initialization that doesn’t use the const modifier:
</p>

<p>
char * word = "frame";
</p>

<p>
Can you use the pointer to change this string?
</p>

<p>
word[1] = 'l'; // allowed??
</p>

<p>
Your compiler may allow this, but, under the current C standard, the behavior for such an
action is undefined. Such a statement could, for example, lead to memory access errors. The
reason is that, as mentioned before, a compiler can choose to represent all identical string literals
with a single copy in memory. For example, the following statements could all refer to a
single memory location of string "Klingon" :
</p>

<p>
char * p1 = "Klingon";
p1[0] = 'F'; // ok?
printf("Klingon");
printf(": Beware the %ss!\n", "Klingon");
</p>

<p>
That is, the compiler can replace each instance of "Klingon" with the same address. If the
compiler uses this single-copy representation and allows changing p1[0] to 'F', that would 
affect all uses of the string, so statements printing the string literal "Klingon" would actually
display "Flingon" :
</p>

<p>
Flingon: Beware the Flingons!
</p>

<p>
In fact, in the past, several compilers did behave this rather confusing way, whereas others
produced programs that abort. Therefore, the recommended practice for initializing a pointer to
a string literal is to use the const modifier:
</p>

<p>
const char * pl = "Klingon"; // recommended usage
</p>

<p>
Initializing a non- const array with a string literal, however, poses no such problems, because
the array gets a copy of the original string.
In short, don’t use a pointer to a string literal if you plan to alter the string. 
</p>
</div>
</div>
<div id="outline-container-org1d5cf6a" class="outline-3">
<h3 id="org1d5cf6a"><span class="section-number-3">1.5</span> Arrays of character Strings</h3>
<div class="outline-text-3" id="text-1-5">
<div class="org-src-container">
<pre class="src src-c">// arrchar.c -- array of pointers, array of strings
#include &lt;stdio.h&gt;
#define SLEN 40
#define LIM 5
int main(void)
{
const char *mytalents[LIM] = {
"Adding numbers swiftly",
"Multiplying accurately", "Stashing data",
"Following instructions to the letter",
"Understanding the C language"
};
char yourtalents[LIM][SLEN] = {
"Walking in a straight line",
"Sleeping", "Watching television",
"Mailing letters", "Reading email"
};
int i;
puts("Let's compare talents.");
printf ("%-36s %-25s\n", "My Talents", "Your Talents");
for (i = 0; i &lt; LIM; i++)
printf("%-36s %-25s\n", mytalents[i], yourtalents[i]);
printf("\nsizeof mytalents: %zd, sizeof yourtalents: %zd\n",
sizeof(mytalents), sizeof(yourtalents));
return 0;
</pre>
</div>
</div>
</div>

<div id="outline-container-org1aa4b69" class="outline-3">
<h3 id="org1aa4b69"><span class="section-number-3">1.6</span> Pointers and Strings</h3>
<div class="outline-text-3" id="text-1-6">
<div class="org-src-container">
<pre class="src src-c">/* p_and_s.c -- pointers and strings */
#include &lt;stdio.h&gt;
int main(void)
{
    const char * mesg = "Don't be a fool!";
    const char * copy;
    copy = mesg;
    printf("%s\n", copy);
    printf("mesg = %s; &amp;mesg = %p; value = %p\n",
    mesg, &amp;mesg, mesg);
    printf("copy = %s; &amp;copy = %p; value = %p\n",
    copy, &amp;copy, copy);
    return 0; 
}
</pre>
</div>
<p>
Looking at this program, you might think that it makes a copy of the string "Don't be a
fool!" , and your first glance at the output might seem to confirm this guess:
Don't be a fool!
mesg = Don't be a fool!; &amp;mesg = 0x0012ff48; value = 0x0040a000
copy = Don't be a fool!; &amp;copy = 0x0012ff44; value = 0x0040a000
</p>
</div>
</div>
<div id="outline-container-org0e07ab0" class="outline-3">
<h3 id="org0e07ab0"><span class="section-number-3">1.7</span> string input</h3>
<div class="outline-text-3" id="text-1-7">
</div><div id="outline-container-orgd58de90" class="outline-4">
<h4 id="orgd58de90"><span class="section-number-4">1.7.1</span> alternatives to gets</h4>
<div class="outline-text-4" id="text-1-7-1">
<p>
The fgets() Function (and fputs() )
Here is how fgets() differs from gets() :
</p>
<ul class="org-ul">
<li>It takes a second argument indicating the maximum number of
characters to read. If thisargument has the value n , fgets() reads
up to n-1 characters or through the newline character, whichever
comes first.</li>
<li>If fgets() reads the newline, it stores it in the string, unlike
gets() , which discards it.</li>
<li>It takes a third argument indicating which file to read. To read
from the keyboard, use</li>
</ul>
<p>
stdin (for standard input ) as the argument; this identifier is defined in stdio.h .
</p>

<p>
Because the fgets() function includes the newline as part of the
string (assuming the input line fits), it’s often paired with fputs()
, which works like puts() , except that it doesn’t auto- matically
append a newline. It takes a second argument to indicate which file to
write to. For the computer monitor we can use stdout (for standard
output) as an argument. Listing 11.7 illustrates how fgets() and
fputs() behave.
</p>

<div class="org-src-container">
<pre class="src src-c">/* fgets1.c -- using fgets() and fputs() */
#include &lt;stdio.h&gt;
#define STLEN 14
int main(void)
{
    char words[STLEN];
    puts("Enter a string, please.");
    fgets(words, STLEN, stdin);
    printf("Your string twice (puts(), then fputs()):\n");
    puts(words);
    fputs(words, stdout);
    puts("Enter another string, please.");
    fgets(words, STLEN, stdin);
    printf("Your string twice (puts(), then fputs()):\n");
    puts(words);
    fputs(words, stdout);
    puts("Done.");
    return 0;
}
</pre>
</div>

<p>
The fgets() function returns a pointer to char . If all goes well, it just returns the same address
that was passed to it as the first argument. If the function encounters end-of-file, however,
it returns a special pointer called the null pointer .
</p>

<div class="org-src-container">
<pre class="src src-c">/* fgets2.c -- using fgets() and fputs() */
#include &lt;stdio.h&gt;
#define STLEN 10
int main(void)
{
    char words[STLEN];
    puts("Enter strings (empty line to quit):");
    while (fgets(words, STLEN, stdin) != NULL &amp;&amp; words[0] != '\n')
    fputs(words, stdout);
    puts("Done.");
    return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdfb44c9" class="outline-4">
<h4 id="orgdfb44c9"><span class="section-number-4">1.7.2</span> scanf() function</h4>
<div class="outline-text-4" id="text-1-7-2">
<p>
If you use the %s format, the string runs up to (but not including)
the next whitespace character (blank, tab, or newline). If you specify
a field width, as in %10s , the scanf() collects up to 10 characters
or up to the first whitespace character, whichever comes first.
</p>

<p>
scanf() function returns an integer value that equals the number of items
successfully read or returns EOF if it encounters the end of file.
</p>

<div class="org-src-container">
<pre class="src src-c">/* scan_str.c -- using scanf() */
#include &lt;stdio.h&gt;
int main(void)
{
    char name1[11], name2[11];
    int count;
    printf("Please enter 2 names.\n");
    count = scanf("%5s %10s",name1, name2);
    printf("I read the %d names %s and %s.\n",
    count, name1, name2);
    return 0;
}
</pre>
</div>
<pre class="example">
Here are three runs:
Please enter 2 names.
Jesse Jukes
I read the 2 names Jesse and Jukes.
Please enter 2 names.
Liza Applebottham
I read the 2 names Liza and Applebotth.
Please enter 2 names.
Portensia Callowit
I read the 2 names Porte and nsia.
</pre>

<p>
In the first example, both names fell within the allowed size limits. In the second example,
only the first 10 characters of Applebottham were read because we used a %10s format. In the
third example, the last four letters of Portensia went into name2 because the second call to
scanf() resumed reading input where the first ended; in this case, that was still inside the
word Portensia.
</p>
</div>
</div>
</div>

<div id="outline-container-org0dbef1a" class="outline-3">
<h3 id="org0dbef1a"><span class="section-number-3">1.8</span> string output</h3>
</div>
<div id="outline-container-orgec1c9ec" class="outline-3">
<h3 id="orgec1c9ec"><span class="section-number-3">1.9</span> Null character and Null pointer</h3>
<div class="outline-text-3" id="text-1-9">
<p>
Null character and null pointer both appear in Listing 11.9 . Conceptually, these two nulls are
different from one another. The null character, or '\0' , is the character used to mark the end
of a C string. It’s the character whose code is zero.
The null pointer, or NULL , has a value that doesn’t correspond to a valid address of data.
So the null character is an integer type, while the null pointer is a pointer type.
Also, while the null character, being a character, is one
byte, the null pointer, being an address, typically is four bytes.
</p>
</div>
</div>
<div id="outline-container-org15afa4f" class="outline-3">
<h3 id="org15afa4f"><span class="section-number-3">1.10</span> string length example</h3>
<div class="outline-text-3" id="text-1-10">
<div class="org-src-container">
<pre class="src src-c">// Function to count the number of characters in a string

#include &lt;stdio.h&gt;

int  stringLength (const char  string[])
{
    int  count = 0;

    while ( string[count] != '\0' )
	++count;

    return count;
}

int main (void)
{
    int   stringLength (const char  string[]);
    const char  word1[] = { 'a', 's', 't', 'e', 'r', '\0' };
    const char  word2[] = { 'a', 't', '\0' };
    const char  word3[] = { 'a', 'w', 'e', '\0' };

    printf ("%i   %i   %i\n", stringLength (word1),
	     stringLength (word2), stringLength (word3));

    return 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org8c095ff" class="outline-3">
<h3 id="org8c095ff"><span class="section-number-3">1.11</span> concatenation of strings example</h3>
<div class="outline-text-3" id="text-1-11">
<div class="org-src-container">
<pre class="src src-c">#include &lt;stdio.h&gt;

int main (void)
{
    void  concat (char  result[], const char  str1[], const char  str2[]);
    const char  s1[] = { "Test " };
    const char  s2[] = { "works." };
    char  s3[20];

    concat (s3, s1, s2);

    printf ("%s\n", s3);

    return 0;
}

// Function to concatenate two character strings

void concat (char  result[], const char  str1[], const char  str2[])
{
    int  i, j;

    // copy str1 to result

    for ( i = 0;  str1[i] != '\0';  ++i )
	result[i] = str1[i];

    // copy str2 to result

    for ( j = 0;  str2[j] != '\0';  ++j )
	result[i + j] = str2[j];

    // Terminate the concatenated string with a null character

    result [i + j] = '\0';
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc6af7a1" class="outline-3">
<h3 id="orgc6af7a1"><span class="section-number-3">1.12</span> startsWith</h3>
<div class="outline-text-3" id="text-1-12">
<div class="org-src-container">
<pre class="src src-c">int startsWith(const char *string, const char *prefix) {
  while(*prefix) {
    if(*prefix++ != *string++) {
      return 0;
    }
  }
  return 1;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org3eecf7d" class="outline-3">
<h3 id="org3eecf7d"><span class="section-number-3">1.13</span> equalStrings example</h3>
<div class="outline-text-3" id="text-1-13">
<div class="org-src-container">
<pre class="src src-c">// Function to determine if two strings are equal

#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

bool equalStrings (const char  s1[], const char  s2[])
{
    int  i = 0;
    bool areEqual;

    while ( s1[i] == s2 [i]  &amp;&amp;
		 s1[i] != '\0' &amp;&amp;  s2[i] != '\0' )
	++i;

    if ( s1[i] == '\0'  &amp;&amp;  s2[i] == '\0' )
       areEqual = true;
    else
       areEqual = false;

    return areEqual;
}


int main (void)
{
     bool  equalStrings (const char  s1[], const char  s2[]);
     const char  stra[] = "string compare test";
     const char  strb[] = "string";

     printf ("%i\n", equalStrings (stra, strb));
     printf ("%i\n", equalStrings (stra, stra));
     printf ("%i\n", equalStrings (strb, "string"));

     return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org5b383f3" class="outline-3">
<h3 id="org5b383f3"><span class="section-number-3">1.14</span> read string with scanf</h3>
<div class="outline-text-3" id="text-1-14">
<div class="org-src-container">
<pre class="src src-c">//  Program to illustrate the %s scanf format characters

#include &lt;stdio.h&gt;

int main (void)
{
    char  s1[81], s2[81], s3[81];

    printf ("Enter text:\n");

    scanf ("%s%s%s", s1, s2, s3);

    printf ("\ns1 = %s\ns2 = %s\ns3 = %s\n", s1, s2, s3);
    return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org2824c3f" class="outline-3">
<h3 id="org2824c3f"><span class="section-number-3">1.15</span> reading lines of code</h3>
<div class="outline-text-3" id="text-1-15">
<div class="org-src-container">
<pre class="src src-c">#include &lt;stdio.h&gt;

int main (void)
{
    int   i;
    char  line[81];
    void  readLine (char  buffer[]);

    for ( i = 0; i &lt; 3; ++i )
    {
	readLine (line);
	printf ("%s\n\n", line);
    }

    return 0;
}

// Function to read a line of text from the terminal

void  readLine (char  buffer[])
{
    char  character;
    int   i = 0;

    do
    {
	character = getchar ();
	buffer[i] = character;
	++i;
    }
    while ( character != '\n' );

    buffer[i - 1] = '\0';
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgaefb6f2" class="outline-3">
<h3 id="orgaefb6f2"><span class="section-number-3">1.16</span> Initializing and Displaying Character Strings</h3>
<div class="outline-text-3" id="text-1-16">
<p>
C permits a character array to be initialized by simply specifying a
constant character string rather than a list of individual
characters. So, for example, the statement
</p>

<p>
char  word[] = { "Hello!" };
</p>

<p>
can be used to set up an array of characters called word with the
initial characters ’H’, ’e’, ’l’, ’l’, ’o’, ’!’, and ’\0’,
respectively. You can also omit the braces when initializing character
arrays in this manner. So, the statement
</p>

<p>
char word[] =  "Hello!";
</p>

<p>
is perfectly valid. Either statement is equivalent to the statement
</p>

<p>
Click here to view code image
</p>

<p>
char  word[] = { 'H', 'e', 'l', 'l', 'o', '!', '\0' };
</p>

<p>
If you’re explicitly specifying the size of the array, make certain
you leave enough space for the terminating null character. So, in
</p>

<p>
char  word[7] = { "Hello!" };
</p>

<p>
the compiler has enough room in the array to place the terminating null character. However, in
</p>

<p>
char  word[6] = { "Hello!" };
</p>

<p>
the compiler can’t fit a terminating null character at the end of the
array, and so it doesn’t put one there (and it doesn’t complain about
it either).
</p>
</div>
</div>
<div id="outline-container-org99cceb4" class="outline-3">
<h3 id="org99cceb4"><span class="section-number-3">1.17</span> Counting words</h3>
<div class="outline-text-3" id="text-1-17">
<div class="org-src-container">
<pre class="src src-c">//  Function to determine if a character is alphabetic

#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

bool alphabetic (const char  c)
{
    if  ( (c &gt;= 'a'  &amp;&amp;  c &lt;= 'z') || (c &gt;= 'A'  &amp;&amp;  c &lt;= 'Z') )
       return true;
    else
       return false;
}

/* Function to count the number of words in a string */

int  countWords (const char  string[])
{
    int   i, wordCount = 0;
    bool  lookingForWord = true, alphabetic (const char  c);

    for ( i = 0;  string[i] != '\0';  ++i )
	if ( alphabetic(string[i]) )
	{
	    if ( lookingForWord )
	    {
		++wordCount;
		lookingForWord = false;
	    }
	}
	else
	    lookingForWord = true;

    return wordCount;
}

int main (void)
{
    const char  text1[] = "Well, here goes.";
    const char  text2[] = "And here we go... again.";
    int   countWords (const char  string[]);

    printf ("%s - words = %i\n", text1, countWords (text1));
    printf ("%s - words = %i\n", text2, countWords (text2));

    return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgeaca293" class="outline-3">
<h3 id="orgeaca293"><span class="section-number-3">1.18</span> Converting a String to its Integer Equivalent</h3>
<div class="outline-text-3" id="text-1-18">
<div class="org-src-container">
<pre class="src src-c">// Function to convert a string to an integer

#include &lt;stdio.h&gt;

int  strToInt (const char  string[])
{
    int  i, intValue, result = 0;

    for  ( i = 0; string[i] &gt;= '0' &amp;&amp; string[i] &lt;= '9'; ++i )
    {
	intValue = string[i] - '0';
	result = result * 10 + intValue;
    }

    return result;
}

int main (void)
{
    int  strToInt (const char  string[]);

    printf ("%i\n", strToInt("245"));
    printf ("%i\n", strToInt("100") + 25);
    printf ("%i\n", strToInt("13x5"));

    return 0;
}
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: moh</p>
<p class="date">Created: 2017-01-18 Wed 18:17</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
